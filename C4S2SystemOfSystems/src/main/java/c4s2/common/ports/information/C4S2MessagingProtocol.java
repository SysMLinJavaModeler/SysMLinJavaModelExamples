package c4s2.common.ports.information;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.StringJoiner;
import c4s2.common.messages.OperatorServiceControlMessage;
import c4s2.common.messages.OperatorServiceMonitorMessage;
import c4s2.common.messages.RadarControlMessage;
import c4s2.common.messages.RadarMonitorMessage;
import c4s2.common.messages.RadarServiceControlMessage;
import c4s2.common.messages.RadarServiceMonitorMessage;
import c4s2.common.messages.RadarSystemControlMessage;
import c4s2.common.messages.RadarSystemMonitorMessage;
import c4s2.common.messages.StrikeControlMessage;
import c4s2.common.messages.StrikeMonitorMessage;
import c4s2.common.messages.StrikeServiceControlMessage;
import c4s2.common.messages.StrikeServiceMonitorMessage;
import c4s2.common.messages.StrikeSystemControlMessage;
import c4s2.common.messages.StrikeSystemMonitorMessage;
import c4s2.common.messages.SystemControlMessage;
import c4s2.common.messages.SystemMonitorMessage;
import c4s2.common.messages.SystemServiceControlMessage;
import c4s2.common.messages.SystemServiceMonitorMessage;
import c4s2.common.messages.TargetControlMessage;
import c4s2.common.messages.TargetMonitorMessage;
import c4s2.common.messages.TargetServiceControlMessage;
import c4s2.common.messages.TargetServiceMonitorMessage;
import sysmlinjava.annotations.FullPort;
import sysmlinjava.annotations.Value;
import sysmlinjava.annotations.comments.Problem;
import sysmlinjava.blocks.SysMLBlock;
import sysmlinjava.comments.SysMLProblem;
import sysmlinjava.common.SysMLClass;
import sysmlinjava.ports.SysMLFullPort;
import sysmlinjava.valuetypes.KeyValueMap;
import sysmlinjavalibrary.common.messages.Message;
import sysmlinjavalibrary.common.ports.information.MessagingP2PProtocol;

/**
 * The C4S2MessagingProtocol is a full port that implements a messaging protocol
 * between message publishers and subscribers. It is a peer-to-peer (P2P)
 * messaging protocol in that messages are sent directly from publisher to
 * subscribers, i.e. there is no messaging server in between the publishers and
 * subscribers.
 * <p>
 * Message subscriptions are maintained within each instance of the protocol
 * which is typically a port in any software service component that uses
 * messaging. The subscriptions are represented by a map collection that maps a
 * type of message to a set of protocol instances that are to receive all
 * messages of that type. The connections between the publishers' and
 * subscribers' messaging protocol ports are currently made during C4S2Domain
 * initialization. Connections must conform to the subscriptions map. The
 * protocol port contains a SysMLIssue that suggests a dynamic
 * connection/disconnection capability is warranted for this protocol.
 * 
 * @author ModelerOne
 *
 */
public class C4S2MessagingProtocol extends SysMLFullPort
{
	/**
	 * Nested port for a P2P messaging protocol with the OperatorServices
	 */
	@FullPort
	public MessagingP2PProtocol operatorServicesMessaging;
	/**
	 * Nested port for a P2P messaging protocol with the RadarServices
	 */
	@FullPort
	public MessagingP2PProtocol radarServicesMessaging;
	/**
	 * Nested port for a P2P messaging protocol with the StrikeServices
	 */
	@FullPort
	public MessagingP2PProtocol strikeServicesMessaging;
	/**
	 * Nested port for a P2P messaging protocol with the TargetServices
	 */
	@FullPort
	public MessagingP2PProtocol targetServicesMessaging;
	/**
	 * Nested port for a P2P messaging protocol with the SystemServices
	 */
	@FullPort
	public MessagingP2PProtocol systemServicesMessaging;
	/**
	 * Nested port for a P2P messaging protocol with the RadarSystem
	 */
	@FullPort
	public MessagingP2PProtocol radarSystemMessaging;
	/**
	 * Nested port for a P2P messaging protocol with the StrikeSystem
	 */
	@FullPort
	public MessagingP2PProtocol strikeSystemMessaging;

	/**
	 * Mappings of message types to messaging protocol instances, i.e. the message
	 * subscriptions
	 */
	@Value
	public KeyValueMap<Class<? extends Message>, List<MessagingP2PProtocol>> messageToMessagingPortsMap;

	/**
	 * Constructor for specification of the context block (block in which this port
	 * resides), and unique ID and name.
	 * 
	 * @param contextBlock block in which this port resides and is to accept events
	 *                     generated by the nested P2P ports
	 * @param id           unique ID number
	 * @param name         unique name
	 */
	public C4S2MessagingProtocol(SysMLBlock contextBlock, Long id, String name)
	{
		super(contextBlock, Optional.of(contextBlock), id, name);
		this.createMessageToMessagingPortsMap();
	}

	/**
	 * Problem that identifies the issue of adding a capability for dynamic
	 * subscriptions
	 */
	@Problem
	public SysMLProblem dynamicSubscriptionsIssue;

	/**
	 * Transmits the specified message to P2P messaging ports mapped to this message
	 * type
	 * 
	 * @param messageObject instance of a Message-based class to be transmitted to messaging ports
	 */
	@Override
	public void transmit(SysMLClass messageObject)
	{
		if (messageObject instanceof Message message)
		{
			message.publishedTime = Instant.now();
			StringJoiner logString = new StringJoiner(",", "Message type: " + message.identityString() + "[", "]");
			List<MessagingP2PProtocol> ports = messageToMessagingPortsMap.get(message.getClass());
			
			if (ports != null && !ports.isEmpty())
			{
				for (MessagingP2PProtocol port : ports)
				{
					port.transmit(message);
					logString.add(port.identityString());
				}
				logger.info(logString.toString());
			}
			else
				logger.warning("no subscriber ports for message class \"" + message.getClass().getSimpleName() + "\"");
		}
		else
			logger.warning("unrecognized (not a Message) object: " + messageObject.getClass().getSimpleName());
	}

	@Override
	protected void createValues()
	{
		super.createValues();
		messageToMessagingPortsMap = new KeyValueMap<>();
	}

	@Override
	protected void createFullPorts()
	{
		super.createFullPorts();
		operatorServicesMessaging = new MessagingP2PProtocol(contextBlock.get(), 0L, "OperatorServicesMessaging");
		radarServicesMessaging = new MessagingP2PProtocol(contextBlock.get(), 0L, "RadarServicesMessaging");
		strikeServicesMessaging = new MessagingP2PProtocol(contextBlock.get(), 0L, "StrikeServicesMessaging");
		targetServicesMessaging = new MessagingP2PProtocol(contextBlock.get(), 0L, "TargetServicesMessaging");
		systemServicesMessaging = new MessagingP2PProtocol(contextBlock.get(), 0L, "SystemServicesMessaging");
		radarSystemMessaging = new MessagingP2PProtocol(contextBlock.get(), 0L, "RadarSystemMessaging");
		strikeSystemMessaging = new MessagingP2PProtocol(contextBlock.get(), 0L, "StrikeSystemMessaging");
	}

	@Override
	protected void createProblems()
	{
		super.createProblems();
		dynamicSubscriptionsIssue = new SysMLProblem("Port should have the capability to establish subscriptions dynamically, not just as part of instantiation as is currently the case");
	}

	protected void createMessageToMessagingPortsMap()
	{
		messageToMessagingPortsMap.put(OperatorServiceControlMessage.class, List.of(operatorServicesMessaging));
		messageToMessagingPortsMap.put(OperatorServiceMonitorMessage.class, List.of(systemServicesMessaging));
		messageToMessagingPortsMap.put(RadarServiceControlMessage.class, List.of(radarServicesMessaging));
		messageToMessagingPortsMap.put(RadarServiceMonitorMessage.class, List.of(systemServicesMessaging));
		messageToMessagingPortsMap.put(TargetServiceControlMessage.class, List.of(targetServicesMessaging));
		messageToMessagingPortsMap.put(TargetServiceMonitorMessage.class, List.of(systemServicesMessaging));
		messageToMessagingPortsMap.put(StrikeServiceControlMessage.class, List.of(strikeServicesMessaging));
		messageToMessagingPortsMap.put(StrikeServiceMonitorMessage.class, List.of(systemServicesMessaging));
		messageToMessagingPortsMap.put(SystemServiceControlMessage.class, List.of(systemServicesMessaging));
		messageToMessagingPortsMap.put(SystemServiceMonitorMessage.class, List.of(systemServicesMessaging));
		messageToMessagingPortsMap.put(RadarControlMessage.class, List.of(radarServicesMessaging));
		messageToMessagingPortsMap.put(RadarMonitorMessage.class, List.of(operatorServicesMessaging, targetServicesMessaging));
		messageToMessagingPortsMap.put(TargetControlMessage.class, List.of(targetServicesMessaging));
		messageToMessagingPortsMap.put(TargetMonitorMessage.class, List.of(operatorServicesMessaging, strikeSystemMessaging));
		messageToMessagingPortsMap.put(StrikeControlMessage.class, List.of(strikeServicesMessaging));
		messageToMessagingPortsMap.put(StrikeMonitorMessage.class, List.of(operatorServicesMessaging));
		messageToMessagingPortsMap.put(SystemControlMessage.class, List.of(systemServicesMessaging));
		messageToMessagingPortsMap.put(SystemMonitorMessage.class, List.of(operatorServicesMessaging));
		messageToMessagingPortsMap.put(RadarSystemControlMessage.class, List.of(radarSystemMessaging));
		messageToMessagingPortsMap.put(RadarSystemMonitorMessage.class, List.of(radarServicesMessaging));
		messageToMessagingPortsMap.put(StrikeSystemControlMessage.class, List.of(strikeSystemMessaging));
		messageToMessagingPortsMap.put(StrikeSystemMonitorMessage.class, List.of(strikeServicesMessaging));
	}
}
